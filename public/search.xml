<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Python 学习]]></title>
      <url>http://github.com/Sessionking/2016/09/08/Python-%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git 管理]]></title>
      <url>http://github.com/Sessionking/2016/08/26/Git-%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="切换、查看、删除分支"><a href="#切换、查看、删除分支" class="headerlink" title="切换、查看、删除分支"></a>切换、查看、删除分支</h2><ul>
<li>切换分支  </li>
</ul>
<p>新分支：<figure class="highlight plain"><figcaption><span>git checkout -b test```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">本地存在： ```$ git checkout test</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>git checkout -f test  强制切换</p>
</blockquote>
<ul>
<li>查看分支</li>
</ul>
<p>远程 <figure class="highlight plain"><figcaption><span>git branch -a```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">本地 ```$ git branch</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<ul>
<li>删除分支</li>
</ul>
<p>本地<figure class="highlight plain"><figcaption><span>git checkout -d test```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">远程```$ git push origin --delete test</span><br></pre></td></tr></table></figure></p>
<h2 id="merge-后如何撤销"><a href="#merge-后如何撤销" class="headerlink" title="merge 后如何撤销"></a>merge 后如何撤销</h2><ul>
<li>reset</li>
</ul>
<blockquote>
<p>git checkout merge时的分支</p>
<p>git reset –hard  merge之前的分支（默认当时的）</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[html转义问题]]></title>
      <url>http://github.com/Sessionking/2016/08/26/html%E8%BD%AC%E4%B9%89%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><blockquote>
<p>将具有功能性的字符，经过转义后会展示在页面上；</p>
<h2 id="不转义"><a href="#不转义" class="headerlink" title="不转义"></a>不转义</h2><p>功能型字符如果不转义，会当做功能字符使用</p>
</blockquote>
<h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">str</span>=<span class="string">'&amp;lt;p&amp;gt;如果您觉得好用，别忘了推荐给朋友！&amp;lt;/p&amp;gt;'</span></span><br><span class="line">document.write(<span class="keyword">str</span>);</span><br><span class="line"><span class="comment">//页面展示为：&lt;p&gt;...........&lt;/p&gt;</span></span><br><span class="line"></span><br><span class="line">var <span class="keyword">str</span>=<span class="string">'&lt;p&gt;.............&lt;/p&gt;'</span>;</span><br><span class="line">document.write(<span class="keyword">str</span>);</span><br><span class="line"><span class="comment">//页面展示为：..............</span></span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[a标签的锚点问题]]></title>
      <url>http://github.com/Sessionking/2016/08/23/a%E6%A0%87%E7%AD%BE%E7%9A%84%E9%94%9A%E7%82%B9%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h1><h2 id="锚点的使用"><a href="#锚点的使用" class="headerlink" title="锚点的使用"></a>锚点的使用</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'#xiaoyu'</span>&gt;</span>锚点<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">'xiaoyu'</span>&gt;</span>我是锚点锚点点<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这时，点击a就可以跳转到段落P处。同时，锚点的对象还可以使用name来进行跳转，但是由于经常会出现锚点失效的情况，所以就考虑使用id来代替name。</p>
</blockquote>
<h2 id="锚点失效问题"><a href="#锚点失效问题" class="headerlink" title="锚点失效问题"></a>锚点失效问题</h2><blockquote>
<p>在iframe中锚点的跳转会失效,可以通过jQuery中的animate 结合 scrollTop来进行跳转。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[path模块处理文件路径]]></title>
      <url>http://github.com/Sessionking/2016/08/22/path%E6%A8%A1%E5%9D%97%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/</url>
      <content type="html"><![CDATA[<h1 id="path模块处理文件路径问题"><a href="#path模块处理文件路径问题" class="headerlink" title="path模块处理文件路径问题"></a>path模块处理文件路径问题</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path=<span class="built_in">require</span>(<span class="string">'path'</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note：<strong>dirname  指的是当前文件所在目录
</strong>dirname=”/a/b/c”;</p>
</blockquote>
<p>(1) path.join(arg1,arg1….),连接多个路径字符串</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> a= path.<span class="keyword">join</span>(__dirname,<span class="string">'/src'</span>,<span class="string">'/xiaoyu'</span>);</span><br><span class="line">console.<span class="keyword">log</span>(a);</span><br><span class="line"><span class="comment">//结果为  /当前文件目录/src/xiaoyu</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>(2) path.resolve(from,…,to),相当于执行多次cd from ,cd to</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=path.resolve(<span class="string">'foo/bar'</span>,<span class="string">'/dd'</span>,<span class="string">'../cc'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">//结果为  /cc</span></span><br></pre></td></tr></table></figure>
<p>(3) path.normalize(path),格式化路径</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a=path.normalize('foo/<span class="built_in">bar</span><span class="comment">//a/ss//c');</span></span><br><span class="line">console.<span class="built_in">log</span>(a);</span><br><span class="line"><span class="comment">//结果为  foo/bar/a/ss/c</span></span><br></pre></td></tr></table></figure>
<p>(4) path.dirname(path),path.basename(path,path1,..),path.extname(p),获取路径的各个部分</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var pathStr=<span class="string">'/User/Session/hexo/blog/test.js'</span>;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">path</span>.dirname(pathStr));</span><br><span class="line"><span class="comment">//当前文件所在目录，结果 /User/Session/hexo/blog </span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">path</span>.basename(pathStr));</span><br><span class="line"><span class="comment">//获取文件带后缀的名称，test.js</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">path</span>.extname(pathStr));</span><br><span class="line"><span class="comment">//获取文件的扩展名 .js	</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">path</span>.basename(pathStr,<span class="string">'.js'</span>));<span class="comment">// test</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">path</span>.basename(pathStr,<span class="string">'.html'</span>));<span class="comment">// test.js</span></span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[word-break word-wrap white-space等]]></title>
      <url>http://github.com/Sessionking/2016/08/20/word-break/</url>
      <content type="html"><![CDATA[<h1 id="文本换行"><a href="#文本换行" class="headerlink" title="文本换行"></a>文本换行</h1><blockquote>
<p>box 需要固定宽度 给定一个width,并且是一个块级元素或者行内块(display:block;)</p>
</blockquote>
<table>
<thead>
<tr>
<th>序号</th>
<th style="text-align:left">属性</th>
<th style="text-align:left">取值</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:left">word-break</td>
<td style="text-align:left">normal/break-all/keep-all</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:left">word-wrap</td>
<td style="text-align:left">normal/word-break</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:left">white-space</td>
<td style="text-align:left">normal/pre/nowrap/pre-line/pre-wrap/inherit</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>#详细介绍</p>
<p>(1) word-break</p>
<table>
<thead>
<tr>
<th>序号</th>
<th style="text-align:left">取值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:left">normal</td>
<td style="text-align:left">使用浏览器的换行规则进行换行，默认值</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:left">break-all</td>
<td style="text-align:left">强行截断单词，达到词内换行的效果</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:left">keep-all</td>
<td style="text-align:left">只能在<em>半角空格或连字符</em>处换行，不允许截断英文单词</td>
</tr>
</tbody>
</table>
<p>(2) word-wrap</p>
<table>
<thead>
<tr>
<th>序号</th>
<th style="text-align:left">取值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:left">normal</td>
<td style="text-align:left">使用浏览器的换行规则进行换行</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:left">break-word</td>
<td style="text-align:left">不截断单词换行，碰到边界后自动换行，如果单词很长，直接整个单词换行</td>
</tr>
</tbody>
</table>
<p>(3) whit-space</p>
<table>
<thead>
<tr>
<th>序号</th>
<th style="text-align:left">取值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:left">normal</td>
<td style="text-align:left">单词之间的空白被浏览器忽略</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:left">pre</td>
<td style="text-align:left">单词间的空白被保留，类似于pre标签</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:left">nowrap</td>
<td style="text-align:left">文本不会换行，在同一行上面，直到遇到<br>为止</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:left">pre-wrap</td>
<td style="text-align:left">保留单之间的空白，但是正常换行</td>
</tr>
<tr>
<td>5</td>
<td style="text-align:left">inherit</td>
<td style="text-align:left">继承父类</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo遇到的问题]]></title>
      <url>http://github.com/Sessionking/2016/08/20/hexo%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="Hexo-的问题-gt-Next-主题"><a href="#Hexo-的问题-gt-Next-主题" class="headerlink" title="Hexo 的问题 -&gt; Next 主题"></a>Hexo 的问题 -&gt; Next 主题</h1><h2 id="新建文章那个后，使用-hexo-g-命令时会提示："><a href="#新建文章那个后，使用-hexo-g-命令时会提示：" class="headerlink" title="新建文章那个后，使用 $hexo g 命令时会提示："></a>新建文章那个后，使用 <code>$hexo g</code> 命令时会提示：</h2><blockquote>
<p>YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 5, column 1:</p>
<p>该类错误主要是由于文章头部的:(冒号)后面需要有一个半角空格</p>
</blockquote>
<h2 id="markdown的图片使用方法"><a href="#markdown的图片使用方法" class="headerlink" title="markdown的图片使用方法"></a>markdown的图片使用方法</h2><blockquote>
<p>图片放在source文件下面的images中，格式如下：</p>
</blockquote>
<p><img src="/images/hexoProblem.png" alt=""></p>
<h2 id="markdwon-中的主副标题无法显示问题"><a href="#markdwon-中的主副标题无法显示问题" class="headerlink" title="markdwon 中的主副标题无法显示问题"></a>markdwon 中的主副标题无法显示问题</h2><blockquote>
<p>井号与文字之间需要添加一个半角空格</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[form 表单的 serialize()]]></title>
      <url>http://github.com/Sessionking/2016/08/15/form-%E8%A1%A8%E5%8D%95%E7%9A%84-serialize/</url>
      <content type="html"><![CDATA[<h2 id="假设表单中有个input"><a href="#假设表单中有个input" class="headerlink" title="假设表单中有个input"></a>假设表单中有个input</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"自填"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">$(<span class="string">"form"</span>).serialize();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>input的value 正常填值会获取value值;但是 如果用户输入”    “ 获取的值为 name=+++  ;用户输入 “” 获取的值为name=  ;其他字符 比如 &nbsp;  \n 等 都有不同的对应的值 并不是 null 或者 空串</p>
<p>$(‘form input’).val();//结果是 input中是什么值就是什么值，不会解析；&nbsp;得到的值就是&nbsp;</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[velocity Tips]]></title>
      <url>http://github.com/Sessionking/2016/08/11/velocity%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="Velocity-Tips"><a href="#Velocity-Tips" class="headerlink" title="Velocity Tips"></a>Velocity Tips</h1><p>1.变量  ${a}  </p>
<blockquote>
<p>注意：a为null 空 或者undefined -&gt;  (1) ${a}或输出 ${a}字串 ;(2) $!{a} 输出空白(虚无）.</p>
</blockquote>
<p>2.声明变量 #set ()</p>
<blockquote>
<pre><code>#set (${a}=&apos;1&apos;)
</code></pre></blockquote>
<p>3.定义函数 #macro   #end</p>
<blockquote>
<p>#macro(a arg1 arg2…) 函数体  #end</p>
<p>函数名是a<br>使用方式是 #a(arg1,arg2..)</p>
</blockquote>
<a id="more"></a>
<p>4.循环 #foreach #end</p>
<blockquote>
<p>循环中可以使用<em>$velocityCount</em>和<em>$foreach.inedx</em>和<em>$foreach.count</em>获取当前循环次数。</p>
<p>使用<em>$foreach.hasNext</em> 可以获取是否是最后一次循环</p>
<p>使用<em>$foreach.first</em>和<em>$foreach.last</em>分别可以获取开始和结束元素</p>
<p>注意:index是从0开始，count和velocityCount是从1开始</p>
</blockquote>
<p>5.对于数组的操作 array</p>
<table>
<thead>
<tr>
<th>序号</th>
<th style="text-align:left">方法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:left">isEmpty()</td>
<td style="text-align:left">判断数组是否为空</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:left">size()</td>
<td style="text-align:left">数组中元素的个数（从1开始）</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:left">get()</td>
<td style="text-align:left">获取数组指定下标的元素（从0开始）</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:left">add()</td>
<td style="text-align:left">添加元素</td>
</tr>
</tbody>
</table>
<p>example：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">set</span> (<span class="variable">$arr</span>=[1,2])</span><br><span class="line"><span class="variable">$arr</span>.<span class="built_in">get</span>(1)</span><br><span class="line"><span class="variable">$arr</span>.size()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在velocity中数组不能通过arr[0]来获取指定下标值</p>
</blockquote>
<p>6.对象访问</p>
<p>example:</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">set</span> (obj=&#123;<span class="string">"age"</span>:12,<span class="string">"name"</span>:<span class="string">"xiaofang"</span>&#125;)</span><br><span class="line">$.obj.age</span><br><span class="line"><span class="variable">$obj</span>.<span class="built_in">get</span>(<span class="string">"age"</span>)</span><br><span class="line">## .属性 和<span class="built_in">get</span>(<span class="string">"属性"</span>)两种方式等价</span><br></pre></td></tr></table></figure>
<p>7.引入其他文件 #include() #parse()  Webx中还可以使用$control.setTemplate()</p>
<p>举个栗子：</p>
<p>a.vm：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#set</span> (<span class="variable">$name</span>=<span class="string">"xiaoyu"</span>)</span><br></pre></td></tr></table></figure>
<p>#include (‘a.vm’)  ${name} -&gt;  #set ($name=’xiaoyu’)</p>
<p>#parse (‘a.vm’)   ${name} -&gt; xiaoyu</p>
<blockquote>
<p>由此可以看出：include引入的文件不能解析velocity语法，而parse可以。但是，parse 不能处理后端逻辑。include可以引入多个参数，使用逗号分开。文件路径以根目录开始（没测试过，使用失败）</p>
<p>#$control.setTemplate() 包含parse的作用，同时还可以处理后端的逻辑（没有测试过，只是在parse失败以后使用它来加载vm文件，囧~~菜）。文件路径以/control 开始（这个测试过）</p>
</blockquote>
<p>#项目中用到的各种奇怪的方法</p>
<blockquote>
<p>其实我也不懂 只是一知半解 反正可以用 o(╯□╰)o</p>
<p>webx基础 velocity模板的工具类 <em>stringUtils</em></p>
</blockquote>
<p>(1) #set ($arrNew=$stringUtils.join(${arr},’,’));将arr数组以逗号连接为字符串</p>
<p>(2) $stringUtils.isNotBlank(${a})  判断字符串是否不为空且且长度不为0 同时，不由空白符构成</p>
<p>(3) $ item.replace(‘:’,’: ‘)  字符串的常用方法</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[url的各个部分的获取方式]]></title>
      <url>http://github.com/Sessionking/2016/08/09/url%E7%9A%84%E5%90%84%E4%B8%AA%E9%83%A8%E5%88%86%E7%9A%84%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="Url的各个部分获取方法"><a href="#Url的各个部分获取方法" class="headerlink" title="Url的各个部分获取方法"></a>Url的各个部分获取方法</h1><p><em>如果你不晓得怎么获取url，你可以浏览器的控制台（console）中输入，window.location 看一下各个属性</em></p>
<h2 id="url的组成部分："><a href="#url的组成部分：" class="headerlink" title="url的组成部分："></a>url的组成部分：</h2><blockquote>
<p>url -&gt; protocol://host:port/path?query#fragment</p>
</blockquote>
<ol>
<li>protocol 是通信协议protocol (http https等)</li>
<li>host 主机（域名or IP，lidayu.cn OR 127.0.0.1等）</li>
<li>port 端口号 （80 OR 8081 等）<a id="more"></a></li>
<li>path 路径 （view/index/index.html 等)</li>
<li>query get请求的查询条件(?name=xiaoyu OR ?name=xiaoyu&amp;value=1 等);</li>
<li>fragment 信息片断,也就是hash值 (#11 OR #indexkey)（添加以后不会对页面起到任何作用，刷新以后值还存在）</li>
</ol>
<blockquote>
<p>举个例子 -&gt;<br><a href="http://www.infoq.com/cn/articles/es6-in-depth-arrow-functions?name=&#39;xiaoyu&#39;#flag" target="_blank" rel="external">http://www.infoq.com/cn/articles/es6-in-depth-arrow-functions?name=&#39;xiaoyu&#39;#flag</a>;</p>
<p>或者<br><a href="http://localhost:8081/script/html/js/index.html?pageSize=10&amp;name=xiaoyu&amp;key=query&amp;value=1#indexKey" target="_blank" rel="external">http://localhost:8081/script/html/js/index.html?pageSize=10&amp;name=xiaoyu&amp;key=query&amp;value=1#indexKey</a></p>
</blockquote>
<p>获取放法表</p>
<table>
<thead>
<tr>
<th>序号</th>
<th style="text-align:left">获取url的某个部分</th>
<th style="text-align:left">获取方法</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:left">url</td>
<td style="text-align:left">window.location.href</td>
<td style="text-align:left">获取整个url</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:left">protocol</td>
<td style="text-align:left">window.location.protocol</td>
<td style="text-align:left">获取协议值</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:left">host</td>
<td style="text-align:left">windwo.location.host</td>
<td style="text-align:left">获取主机名称（与hostname一样？）</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:left">port</td>
<td style="text-align:left">window.location.port</td>
<td style="text-align:left">端口号</td>
</tr>
<tr>
<td>5</td>
<td style="text-align:left">pathname</td>
<td style="text-align:left">window.location.pathname</td>
<td style="text-align:left">路径</td>
</tr>
<tr>
<td>6</td>
<td style="text-align:left">query</td>
<td style="text-align:left">window.location.search</td>
<td style="text-align:left">查询参数</td>
</tr>
<tr>
<td>7</td>
<td style="text-align:left">fragment</td>
<td style="text-align:left">window.location.hash</td>
<td style="text-align:left">hash值</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ES6的小Tips]]></title>
      <url>http://github.com/Sessionking/2016/08/05/ES6%E7%9A%84%E5%B0%8Ftip/</url>
      <content type="html"><![CDATA[<h1 id="读阮一峰老师的ES6后记："><a href="#读阮一峰老师的ES6后记：" class="headerlink" title="读阮一峰老师的ES6后记："></a>读阮一峰老师的ES6后记：</h1><h2 id="ES6的注意点："><a href="#ES6的注意点：" class="headerlink" title="ES6的注意点："></a>ES6的注意点：</h2><p>1.如果块内使用了let 和const命令进行变量声明，那么在声明之前使用这些变量都会报错；</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">0</span>;</span><br><span class="line">&#123;</span><br><span class="line">    a=<span class="number">1</span>; <span class="comment">//会报错，a undefined</span></span><br><span class="line">    <span class="keyword">let</span> a=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span><span class="params">(x=y,y=2)</span>&#123;&#125;;<span class="title">b</span><span class="params">()</span>;</span></span><br><span class="line"><span class="comment">//报错，因为y未声明。如果将第一个和第二个参数互换位置，则不会报错。</span></span><br></pre></td></tr></table></figure>
<p>2.var 声明的变量全局存在，let 声明的只存在某个块内。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">	arr[i]=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">1</span>]();</span><br><span class="line"><span class="comment">//结果控制条输出4,每一次循环的i都会覆盖掉前一次的最后数组函数输出全是最后一个i。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">	arr[i]=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">1</span>]();</span><br><span class="line"><span class="comment">//结果控制条输出1，let声明的i只存在每次的循环中，每一次都不是同一个i，不会被覆盖掉</span></span><br></pre></td></tr></table></figure>
<p>3.不能重复声明变量</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function <span class="function"><span class="title">fun</span><span class="params">()</span></span>&#123;let a=<span class="number">0</span>;<span class="keyword">var</span> a=<span class="number">0</span>;&#125;<span class="comment">//报错</span></span><br><span class="line">function <span class="function"><span class="title">fun</span><span class="params">()</span></span>&#123;let a=<span class="number">0</span>;let a=<span class="number">0</span>;&#125;<span class="comment">//报错</span></span><br><span class="line">function <span class="function"><span class="title">fun</span><span class="params">(arg)</span></span>&#123;let arg=<span class="number">0</span>;&#125;   <span class="comment">//报错</span></span><br><span class="line">function <span class="function"><span class="title">fun</span><span class="params">(arg)</span></span>&#123;&#123;let arg=<span class="number">0</span>;&#125;&#125; <span class="comment">//不报错，（块内，块外访问不到）</span></span><br></pre></td></tr></table></figure>
<p>4.const 声明一个常量，声明后常量的值不能被改变。意味着，声明必须初始化。注意：与let相同，只在声明所在的块级作用域内有效，并且不可以重复声明。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a=<span class="number">0</span>;</span><br><span class="line">a=<span class="number">9</span>;<span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
<p>#ES6小技巧（感觉很好用）：</p>
<p>一、解构赋值（<em>解构赋值是声明和赋值同时进行的，所以不能重复声明。如果左边没有关键字 let 和var 的话可以直接使用，但是变量需要提前声明。</em>）</p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">x</span><span class="comment">;</span></span><br><span class="line">&#123;<span class="keyword">x</span>&#125; = &#123;<span class="keyword">x</span>: <span class="number">1</span>&#125;<span class="comment">;</span></span><br><span class="line"><span class="comment">// 写法错误，系统会认为&#123;x&#125;是一个代码块，正确写法如下</span></span><br><span class="line">（&#123;<span class="keyword">x</span>&#125;=&#123;<span class="keyword">x</span>:<span class="number">1</span>&#125;）<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>1.数组的解构赋值（左右都是数组格式）</p>
<p>(1) 可以按照一定的模式，从数组(<em>必须为数组，否则不能生效</em>）中提取值，并且赋给变量；只要等号两边的模式相同，左边的变量就会被赋予对应的值,不对应的位置变量会undefined。example:按照对应位置赋值。（ES6严格按照===来判断是否相等)</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var [a,b,c]=[<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>];</span><br><span class="line">var [a,[b,c]]=[<span class="string">'1'</span>,[<span class="string">'2'</span>,<span class="string">'3'</span>]];//对应嵌套匹配也可以</span><br><span class="line">var [bar, foo] = [<span class="number">1</span>];//这种情况bar 有值，foo undefined</span><br><span class="line">var [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];//b:<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>(2) 一个数组值如果不严格等于undefined，变量的默认值是不会生效的</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let [a=<span class="number">0</span>]=[<span class="literal">undefined</span>];<span class="regexp">//</span>结果是<span class="literal">undefined</span></span><br><span class="line">let [a=<span class="number">0</span>]=[<span class="literal">null</span>];</span><br><span class="line"><span class="regexp">//</span>因为不是<span class="literal">undefined</span>这个单词(?)，所以结果是<span class="literal">null</span>，默认值不生效，被<span class="literal">null</span> 取代</span><br></pre></td></tr></table></figure>
<p>(3) 默认值还可以是表达式:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let [a=<span class="function"><span class="keyword">fun</span>()]=[1];<span class="title">/</span></span>/与前面讲的取值方式相同</span><br></pre></td></tr></table></figure>
<p>2.对象的解构赋值（左右都是对象格式）</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var &#123;a,b&#125;=&#123;<span class="string">a:</span><span class="string">'name'</span>,<span class="string">b:</span><span class="string">'age'</span>&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>对象的属性名称一定要对应，否则就无法赋值；属性的顺序是无序的，只要名称对应就可以取值</em></p>
<p><em>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。</em></p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var &#123;<span class="string">foo:</span>a,<span class="string">bar:</span>b&#125;=&#123;<span class="string">bar:</span><span class="string">"1"</span>,<span class="string">foo:</span><span class="string">"2"</span>&#125;;</span><br><span class="line"><span class="comment">//先找属性名相同的属性，然后将右边同名属性的值赋给左边同名属性的值变量；因此 a就是1，b就是2；</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>对象和数组的解构赋值是可以嵌套的</em></p>
</blockquote>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">node</span> <span class="title">= &#123;</span><br><span class="line">  loc</span>: &#123;</span><br><span class="line">    <span class="literal">start</span>: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var &#123; loc: &#123; <span class="literal">start</span>: &#123; line &#125;&#125; &#125; = <span class="keyword">node</span><span class="title">;</span><br><span class="line">//只有line</span>是变量，其他的是匹配的模式</span><br></pre></td></tr></table></figure>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; y: <span class="string">'World'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var &#123; p: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x // <span class="string">"Hello"</span></span><br><span class="line">y // <span class="string">"World"</span></span><br><span class="line">//p 是匹配的模式</span><br></pre></td></tr></table></figure>
<p>3.字符串解构赋值</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var [a,b,c]=<span class="string">'hello'</span>;</span><br><span class="line"><span class="regexp">//a</span> -&gt;h, b-&gt;e ,c-&gt;l</span><br></pre></td></tr></table></figure>
<p>以为字符串都有一个length长度属性，所以：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;length:len&#125;=<span class="string">'hello'</span>;</span><br><span class="line"><span class="comment">//len -&gt; 5</span></span><br></pre></td></tr></table></figure>
<p>4.数值和布尔值解构赋值</p>
<p> *等号右边是数值或者布尔值时，会先转换为对象.</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="built_in">toString</span>:s&#125;=<span class="number">123</span>;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="built_in">toString</span>:s&#125;=<span class="literal">true</span>;</span><br><span class="line">//因为布尔值和数值都有<span class="built_in">toString</span>的属性，所以s 有值</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;prop:x&#125;=<span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> &#123;prop:x&#125;=<span class="literal">null</span>;</span><br><span class="line"><span class="comment">//会报错，类型错误</span></span><br></pre></td></tr></table></figure>
<p>5.函数的参数解构赋值</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function <span class="function"><span class="keyword">fun</span>([<span class="title">x</span></span>,y])&#123; <span class="keyword">return</span> x+y;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">fun</span>([1,2]);<span class="title">/</span></span>/ <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].map(([a, b]) =&gt; a + b);<span class="regexp">//</span>ES6的箭头函数[<span class="number">3</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<p>6.ES6允许初始化</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function fun(x=<span class="number">0</span>;y=<span class="number">2</span>)<span class="meta">&#123;...&#125;</span></span><br><span class="line"><span class="keyword">var</span> [a=<span class="number">0</span>,b=<span class="number">0</span>]=[<span class="number">1</span>,<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<p>二、for in  与for of 的区别</p>
<ol>
<li>for in 中声明的变量是索引index，for of 中声明的变量是 value</li>
</ol>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var str=<span class="string">'hello'</span>;</span><br><span class="line">for (let <span class="built_in">index</span> <span class="keyword">in</span> str)&#123;console.<span class="built_in">log</span>(str[<span class="built_in">index</span>])&#125;</span><br><span class="line">// 索引 <span class="built_in">index</span>，结果h e l l o ，<span class="built_in">index</span>的值是<span class="number">0</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"></span><br><span class="line">for (let <span class="keyword">value</span> <span class="keyword">in</span> str)[console.<span class="built_in">log</span>(<span class="keyword">value</span>);&#125;</span><br><span class="line">//值 <span class="keyword">value</span> 相当于for <span class="keyword">in</span>里面的str[<span class="built_in">index</span>]，<span class="keyword">value</span>值是h e l l o</span><br></pre></td></tr></table></figure>
<blockquote>
<p>for of 可以正确识别 大于0xFFFF的16进制码点（example:0x20BB7)</p>
</blockquote>
<p>三、ES6中的字符串查找</p>
<ul>
<li>javascript自带的indexOf函数：第一个参数是需要查找的字符串值，第二个参数非必填,查询的开始位置。</li>
<li>starsWith 第一参数是需要查找的字符串的值，第二个参数非必填,查询开始的位置。</li>
<li>endsWith 第一个参数是需要查找的字符串的值，第二个参数非必填，</li>
<li>repeat 方法返回一个新字符串，表示将原字符串重复n次，0次或者NaN或者字符,输出’’；小数，四舍五入;</li>
</ul>
<p>四、模板字符串</p>
<ol>
<li>ES6中使用html字符串只需要写在<code> </code> 之中就好啦。不需要想ES5繁琐的+了；使用反斜杠对反引号进行转义。</li>
</ol>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str=`&lt;ul&gt;&lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;`;</span><br><span class="line"></span><br><span class="line">var str2=`\`ohha`;</span><br></pre></td></tr></table></figure>
<p>2.模板中嵌套变量，变量或者表达式（1+2）或者函数f()写在 ${} 中;如果变量未声明则报错。一个html字串中如果含有多个（n个）变量，函数入参后，是一个数组，长度为n+1。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str='hello';</span><br><span class="line"><span class="keyword">var</span> str2=`</span><br><span class="line">&lt;p&gt;$&#123;str&#125; world!$&#123;str&#125;&lt;/p&gt;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">function f(a)<span class="meta">&#123;...&#125;</span>;</span><br><span class="line">f`str2`;//arguments.length为<span class="number">3</span>.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所有模板字符串的空格和换行都会被保留，使用 .trim()消除。str2中p前面会有一个换行，如果你不想要换行，介意使用trim()消除。</p>
</blockquote>
<p>3.标签模板，模板是前面函数的标签。表示是函数的模板，不是别人的模板。</p>
<figure class="highlight plain"><figcaption><span>//等价于alert(123);```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">五、正则表达式</span><br><span class="line"></span><br><span class="line">1.创建正则表达式 RegExp *第一个参数*可以是：正则字串或者正则表达式（&apos;xyz&apos;|/xyz/) *第二个参数* 修饰符 flag(i|g|m|u|y) 通过.flags可以获取正则表达式的修饰符;通过.sticky来判断是否使用了y属性;通过.source来获取正则表达式的正文(/正文/修饰符）</span><br></pre></td></tr></table></figure>
<p>var regexp=new RegExp(/xyyz/,’g’);<br>regexp.flags;<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2.字串函数 match() split() replace() search()</span><br><span class="line"></span><br><span class="line">|<span class="string">序号</span>|<span class="string">方法</span>|<span class="string">说明</span>|</span><br><span class="line">|<span class="string">---</span>|<span class="string">:---</span>|<span class="string">:---</span>|</span><br><span class="line">|<span class="string">1</span>|<span class="string">match(a)</span>|<span class="string">在字符串内检索指定的值 a (字符串</span>|<span class="string">正则表达式）,返回找到的一个或者多个匹配值</span>|</span><br><span class="line">|<span class="string">2</span>|<span class="string">split(a)</span>|<span class="string">将字符串按照制定值a进行分隔，得到的结果为数组</span>|</span><br><span class="line">|<span class="string">3</span>|<span class="string">replace(a,b)</span>|<span class="string">在字符串内检索指定值a，然后用b去替换。结果是替换后的字符串</span>|</span><br><span class="line">|<span class="string">4</span>|<span class="string">search(a)</span>|<span class="string">在字符串内检索指定值a，检索到以后返回子串的起始位置，否则-1</span>|</span><br><span class="line"></span><br><span class="line">example：</span><br></pre></td></tr></table></figure></p>
<pre><code>var str=&apos;xiao yu ai chi yu&apos;;
str.match(&apos;ai&apos;);//返回[&apos;ai&apos;]
str.split(&apos; &apos;);//返回[&quot;xiao&quot;, &quot;yu&quot;, &quot;ai&quot;, &quot;chi&quot;, &quot;yu&quot;]，以空格分隔    str.replace(&apos; &apos;,&apos;$&apos;);//返回&quot;xiao$yu ai chi yu&quot;, 替换匹配到的第一个空格
str.replace(/\s+/g,&apos;$&apos;);//替换全局的空格，&quot;xiao$yu$ai$chi$yu&quot;
str.search(&apos;c&apos;);//返回11 从0开始计数，第十二的位置，所以返回11
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;正则表达式有两个方法：<span class="built_in">test</span>() <span class="built_in">exec</span>();<span class="built_in">test</span>用于检测一个字符串是否匹配某个模式，返回布尔值；<span class="built_in">exec</span>用于检索字符串中与正则表达式匹配的子串，并且返回该子串。</span><br><span class="line"></span><br><span class="line"><span class="comment">#作用域 -&gt; 函数默认值：参数的默认值为变量的情况，则该变量所处的作用域，与其他变量的作用域规则是一样的，即先是当前函数的作用域，然后才是全局作用域。。</span></span><br><span class="line"></span><br><span class="line">(1)y的默认值是x，函数作用域内部的变量x已经声明，所以y等于参数x，而不是全局作用域的x。</span><br></pre></td></tr></table></figure>
<pre><code>var x=1;
function fun(x,y=x){
    console.log(y);
}
fun(2);//结果输出 2
</code></pre><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(<span class="number">2</span>) y的默认值是<span class="keyword">x</span>，但是函数作用域内部的<span class="keyword">x</span>还未声明。所以y等于全局作用域的<span class="keyword">x</span>。</span><br></pre></td></tr></table></figure>
<pre><code>var x=1;
function fun(y=x){0;
    let x=
    console.log(y);
}
fun();//结果输出 1
</code></pre><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;注意：</span><br><span class="line"><span class="quote">&gt;</span><br><span class="line">&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>  var x=0;<br>    function fun(x=x){}<br>```</p>
<p>会报错.x is not definder.函数fun的参数x的默认值也是x。这时，默认值x的作用域是函数作用域，而不是全局作用域。由于在函数作用域中，存在变量x，但是默认值在x赋值之前先执行了，所以这时属于暂时性死，任何对x的操作都会报错。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[onChange() onKeyup() onKeydown() 事件的区别]]></title>
      <url>http://github.com/Sessionking/2016/08/04/onChange-onKeyup-onKeydown-%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h1 id="以输入框-input-标签为例："><a href="#以输入框-input-标签为例：" class="headerlink" title="以输入框 input 标签为例："></a>以输入框 input 标签为例：</h1><p>onchange()：该函数在输入框value被改变后，并且失去焦点以后才触发；</p>
<p>onkeyup():该函数在输入框中输入内容后，键盘跳起时触发；</p>
<a id="more"></a>
<p>onkeydown():该函数在输入框输入内容后，键盘再次被按下时触发。</p>
<blockquote>
<p>注：输入框中第一次按下1，第二次按下2。展示的字符只会展示1，而字符2会在按下下一个按键后展示</p>
<p>通俗一点就是，输入框输入了四个一，展示输入框值得p段落中只展示了三个1.因为按下第一个1的时候触发的onkeydown()事件时，输入框value为空。当按键弹起时，输入框中才输入1，这时第一次的onkeydown事件已经触发，只能等待下一次onkeydown事件才能输出input的value值.</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ReactJS学习总结]]></title>
      <url>http://github.com/Sessionking/2016/08/03/ReactJS%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="ReactJs-的内联样式的小问题"><a href="#ReactJs-的内联样式的小问题" class="headerlink" title="ReactJs 的内联样式的小问题"></a>ReactJs 的内联样式的小问题</h1><p>1.属性名称要采用驼峰写法（与原生js中设置属性值一样）</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> style=&#123;</span><br><span class="line">         fontSize:<span class="number">900</span>,</span><br><span class="line">         backgroundColor:<span class="string">'red'</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：React会在元素后面自动加上px,若我们自己加上px，会报错。</p>
<p>在添加属性时， class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。</p>
</blockquote>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">fontSize:</span><span class="number">900</span>px<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>2.数组模式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="string">'1'</span>,<span class="string">'2'</span>];&#123;<span class="comment">/*或者 arr=[&lt;h1&gt;22&lt;/h1&gt;,&lt;h2&gt;333&lt;/h2&gt;]*/</span>&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;arr&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,<span class="built_in">document</span>.body);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>得到的结果：在该块中循环数组的每一个值，外层块，不做循环<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">h1</span>&gt;</span>22<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">h2</span>&gt;</span>333<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>3.React组件名称必须大写，html标签首字母必须小写，以此来区分</p>
<blockquote>
<p>React组件 <figure class="highlight plain"><figcaption><span>Hello=React.createClass(&#123;.....&#125;);```  </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; html标签 ```var hello=&lt;Hello /&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>4.每个React组件只能包含一个顶层标签</p>
<blockquote>
<p>对的写法 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;错的写法```&lt;div&gt;&lt;h1&gt;aa&lt;/h1&gt;&lt;/div&gt;  &lt;div&gt;&lt;h2&gt;222&lt;/h2&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>————————— 我是分割线 ———————–</p>
<blockquote>
<p>【杂七杂八】不分类的玩意儿：<br>select 中不要使用 selected 选中 option，直接给 select 设置 defaultValue 或者 value 来选中 option</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo的基础命令]]></title>
      <url>http://github.com/Sessionking/2016/08/03/hexo%E7%9A%84%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h1 id="Hexo-主题-问题"><a href="#Hexo-主题-问题" class="headerlink" title="Hexo 主题 问题"></a><a href="https://github.com/iissnan/hexo-theme-next">Hexo 主题 问题</a></h1><p>@ 新建</p>
<blockquote>
<p><code>$ hero  new  page &quot;name&quot;</code> 新建页面 md文件</p>
<p><code>$ hero new  &quot;name&quot;</code> 新建文章 （写文章 随笔 就这个了）</p>
</blockquote>
<p>@ 写完以后在根目录下执行以下命令 生成和预览</p>
<blockquote>
<p><code>$ hexo d -g</code>生成 部署</p>
<p><code>$ hexo s</code>  部署 预览 localhost：4000</p>
</blockquote>
<p>@ 如果你想删除一个文件的时候，执行以下命令即可<br><a id="more"></a></p>
<ol>
<li>删除source下面想要删除的文件</li>
<li>执行 <code>$ hero clean</code> 清除数据库，</li>
<li>然后在执行 <code>$ hexo d -g   hexo s</code>本地预览一下吧</li>
</ol>
]]></content>
    </entry>
    
  
  
</search>
